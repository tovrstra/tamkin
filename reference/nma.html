
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. Normal mode analysis &mdash; TAMkin 1.0.5 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="TAMkin 1.0.5 documentation" href="../index.html" />
    <link rel="next" title="4. Partition functions" href="pf.html" />
    <link rel="prev" title="2. Input/output" href="io.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pf.html" title="4. Partition functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="io.html" title="2. Input/output"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">TAMkin 1.0.5 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="normal-mode-analysis">
<h1>3. Normal mode analysis<a class="headerlink" href="#normal-mode-analysis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-different-nma-models">
<h2>3.1. The different NMA models<a class="headerlink" href="#the-different-nma-models" title="Permalink to this headline">¶</a></h2>
<p><strong>Inheritance diagram</strong></p>
<p class="graphviz">
<img src="../_images/inheritance-40964a247b476fa1d04443e9aa427c765068247b.png" alt="Inheritance diagram of tamkin.nma" usemap="#inheritance98b00c76fa" class="inheritance"/>
<map id="inheritance98b00c76fa" name="inheritance98b00c76fa">
<area shape="rect" id="node1" href="#tamkin.nma.PHVA_MBH" title="PHVA_MBH" alt="" coords="6,155,100,181"/>
<area shape="rect" id="node2" href="#tamkin.nma.MBH" title="MBH" alt="" coords="5,81,77,106"/>
<area shape="rect" id="node10" href="#tamkin.nma.MBHConstrainExt" title="MBHConstrainExt" alt="" coords="125,155,259,181"/>
<area shape="rect" id="node3" href="#tamkin.nma.Treatment" title="Treatment" alt="" coords="113,6,199,31"/>
<area shape="rect" id="node4" href="#tamkin.nma.PHVA" title="PHVA" alt="" coords="101,81,173,106"/>
<area shape="rect" id="node8" href="#tamkin.nma.Constrain" title="Constrain" alt="" coords="197,81,280,106"/>
<area shape="rect" id="node11" href="#tamkin.nma.VSANoMass" title="VSANoMass" alt="" coords="305,81,404,106"/>
<area shape="rect" id="node12" href="#tamkin.nma.Full" title="Full" alt="" coords="429,81,501,106"/>
<area shape="rect" id="node13" href="#tamkin.nma.ConstrainExt" title="ConstrainExt" alt="" coords="526,81,628,106"/>
<area shape="rect" id="node14" href="#tamkin.nma.VSA" title="VSA" alt="" coords="653,81,725,106"/>
<area shape="rect" id="node5" href="#tamkin.nma.Blocks" title="Blocks" alt="" coords="224,6,296,31"/>
<area shape="rect" id="node6" href="#tamkin.nma.Transform" title="Transform" alt="" coords="320,6,405,31"/>
<area shape="rect" id="node7" href="#tamkin.nma.AtomDivision" title="AtomDivision" alt="" coords="429,6,536,31"/>
<area shape="rect" id="node9" href="#tamkin.nma.NMA" title="NMA" alt="" coords="560,6,632,31"/>
<area shape="rect" id="node15" href="#tamkin.nma.MassMatrix" title="MassMatrix" alt="" coords="657,6,751,31"/>
</map>
</p>
<span class="target" id="module-tamkin.nma"></span><p>A normal mode analysis is carried out by constructing an NMA object. The first
argument is a molecule object created by one of the IO routines in
<a class="reference internal" href="io.html#module-tamkin.io" title="tamkin.io"><tt class="xref py py-mod docutils literal"><span class="pre">tamkin.io</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nma</span> <span class="o">=</span> <span class="n">NMA</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
</pre></div>
</div>
<p>This leads to a standard normal mode analysis in 3*N degrees of freedom.
The results, including those relevant for the construction of the molecular
partition function, are stored as attributes of the NMA object. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nma</span><span class="o">.</span><span class="n">freqs</span>
</pre></div>
</div>
<p>prints the frequencies of the normal modes. Note that all data is stored in
atomic units and that the freqs array contains really frequencies, not
wavenumbers. If you want to print the wavenumbers in cm**-1, use the unit
conversion constants from the <tt class="docutils literal"><span class="pre">molmod</span></tt> package:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">molmod</span> <span class="kn">import</span> <span class="n">centimeter</span><span class="p">,</span> <span class="n">lightspeed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invcm</span> <span class="o">=</span> <span class="n">lightspeed</span><span class="o">/</span><span class="n">centimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nma</span><span class="o">.</span><span class="n">freqs</span><span class="o">/</span><span class="n">invcm</span>
</pre></div>
</div>
<p>One can also use modified schemes by giving a second argument to the NMA
constructor. The following example computes the normal modes in 3*N-6 degrees
of freedom:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nma</span> <span class="o">=</span> <span class="n">NMA</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="n">ConstrainExt</span><span class="p">())</span>
</pre></div>
</div>
<p>The second argument is an instance of a class that derives from the
<a class="reference internal" href="#tamkin.nma.Treatment" title="tamkin.nma.Treatment"><tt class="xref py py-class docutils literal"><span class="pre">Treatment</span></tt></a> class. Other treatments include: <a class="reference internal" href="#tamkin.nma.Full" title="tamkin.nma.Full"><tt class="xref py py-class docutils literal"><span class="pre">Full</span></tt></a> (the default),
<a class="reference internal" href="#tamkin.nma.PHVA" title="tamkin.nma.PHVA"><tt class="xref py py-class docutils literal"><span class="pre">PHVA</span></tt></a>, <a class="reference internal" href="#tamkin.nma.VSA" title="tamkin.nma.VSA"><tt class="xref py py-class docutils literal"><span class="pre">VSA</span></tt></a>, <a class="reference internal" href="#tamkin.nma.VSANoMass" title="tamkin.nma.VSANoMass"><tt class="xref py py-class docutils literal"><span class="pre">VSANoMass</span></tt></a>, <a class="reference internal" href="#tamkin.nma.MBH" title="tamkin.nma.MBH"><tt class="xref py py-class docutils literal"><span class="pre">MBH</span></tt></a>,
<a class="reference internal" href="#tamkin.nma.PHVA_MBH" title="tamkin.nma.PHVA_MBH"><tt class="xref py py-class docutils literal"><span class="pre">PHVA_MBH</span></tt></a>, <a class="reference internal" href="#tamkin.nma.Constrain" title="tamkin.nma.Constrain"><tt class="xref py py-class docutils literal"><span class="pre">Constrain</span></tt></a>, and <a class="reference internal" href="#tamkin.nma.MBHConstrainExt" title="tamkin.nma.MBHConstrainExt"><tt class="xref py py-class docutils literal"><span class="pre">MBHConstrainExt</span></tt></a>.</p>
<dl class="class">
<dt id="tamkin.nma.NMA">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">NMA</tt><big>(</big><em>molecule</em>, <em>treatment=None</em>, <em>do_modes=True</em><big>)</big><a class="headerlink" href="#tamkin.nma.NMA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A generic normal mode analysis class.</p>
<p>This class gathers the functionality that is common between all types of
NMA variations, i.e. computation of frequencies and modes, once the
problem is transformed to reduced coordinates. The actual nature of the
reduced coordinates is determined by the treatment argument.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">molecule</span></tt> &#8211; a molecule object obtained from a routine in
<a class="reference internal" href="io.html#module-tamkin.io" title="tamkin.io"><tt class="xref py py-mod docutils literal"><span class="pre">tamkin.io</span></tt></a></div>
</div>
</dd>
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">treatment</span></tt> &#8211; an instance of a Treatment subclass
[default=Full()]</div>
<div class="line"><tt class="docutils literal"><span class="pre">do_modes</span></tt> &#8211; When False, only the frequencies are computed.
When True, also the normal modes are computed.
[default=True]</div>
</div>
</dd>
<dt>Referenced attributes of molecule:</dt>
<dd><tt class="docutils literal"><span class="pre">mass</span></tt>, <tt class="docutils literal"><span class="pre">masses</span></tt>, <tt class="docutils literal"><span class="pre">masses3</span></tt>, <tt class="docutils literal"><span class="pre">numbers</span></tt>, <tt class="docutils literal"><span class="pre">coordinates</span></tt>,
<tt class="docutils literal"><span class="pre">inertia_tensor</span></tt>, <tt class="docutils literal"><span class="pre">multiplicity</span></tt>, <tt class="docutils literal"><span class="pre">symmetry_number</span></tt>,
<tt class="docutils literal"><span class="pre">periodic</span></tt>, <tt class="docutils literal"><span class="pre">energy</span></tt></dd>
<dt>Extra attributes:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">freqs</span></tt> &#8211; array of frequencies</div>
<div class="line"><tt class="docutils literal"><span class="pre">modes</span></tt> &#8211; array of mass-weighted Cartesian modes (if do_modes
is True). Each column corresponds to one mode. One
has to divide a column the square root of the masses3
attribute to obtain the mode in non-mass-weighted
coordinates.</div>
<div class="line"><tt class="docutils literal"><span class="pre">zeros</span></tt> &#8211; list of indices of zero frequencies</div>
</div>
</dd>
</dl>
<dl class="classmethod">
<dt id="tamkin.nma.NMA.read_from_file">
<em class="property">classmethod </em><tt class="descname">read_from_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#tamkin.nma.NMA.read_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an NMA object from a previously saved checkpoint file</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">filename</span></tt> &#8211; the file to load from</div>
</div>
</dd>
</dl>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nma</span> <span class="o">=</span> <span class="n">NMA</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="s">&quot;foo.chk&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.NMA.write_to_file">
<tt class="descname">write_to_file</tt><big>(</big><em>filename</em>, <em>fields='all'</em><big>)</big><a class="headerlink" href="#tamkin.nma.NMA.write_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the NMA results to a human-readable checkpoint file.</p>
<dl class="docutils">
<dt>Argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">filename</span></tt> &#8211; the file to write to</div>
</div>
</dd>
<dt>Optional argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">fields</span></tt> &#8211; define the selection of attributes to be written to
file. This is one of &#8216;all&#8217; (all attributes), &#8216;modes&#8217;
(only attributes required for nmatools.py), or
&#8216;partf&#8217; (only attributes required for the
construction of a partition function)</div>
</div>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.AtomDivision">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">AtomDivision</tt><big>(</big><em>transformed</em>, <em>free</em>, <em>fixed</em><big>)</big><a class="headerlink" href="#tamkin.nma.AtomDivision" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A division of atoms into transformed, free and fixed.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">transformed</span></tt> &#8211; the atom indices of the atoms whose coordinates
are transformed into non-Cartesian coordinates.</div>
<div class="line"><tt class="docutils literal"><span class="pre">free</span></tt> &#8211; the atom indices that are not transformed and retained
as Cartesian coordinates in the new set of coordinates</div>
<div class="line"><tt class="docutils literal"><span class="pre">fixed</span></tt> &#8211; the atoms that are not used for the new coordinates,
i.e. their positions are constrained.</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="tamkin.nma.Transform">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">Transform</tt><big>(</big><em>matrix</em>, <em>atom_division=None</em><big>)</big><a class="headerlink" href="#tamkin.nma.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A clever transformation object. It is sparse when atom coordinates remain
Cartesian in the reduced coordinates.</p>
<p>This object transforms small displacements (first order) in reduced
internal coordinates (can be mass weighted) into plain Cartesian
coordinates.</p>
<p>It is assumed that the reduced coordinates are always split into two
parts (in order):</p>
<ol class="arabic simple">
<li>the coordinates that are non-Cartesian</li>
<li>the free coordinates that are Cartesian</li>
</ol>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">matrix</span></tt> &#8211; the linear transformation from the transformed
displacements to Cartesian coordinates.</div>
</div>
</dd>
<dt>Optional argument</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">atom_division</span></tt> &#8211; an AtomDivision instance, when not given all
atom coordinates are <cite>transformed</cite></div>
</div>
</dd>
<dt>Attributes:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">matrix</span></tt> &#8211; see above</div>
<div class="line"><tt class="docutils literal"><span class="pre">scalars</span></tt> &#8211; diagonal part of the linear transformation (only
used with mass-weighted transformations)</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.Transform.__call__">
<tt class="descname">__call__</tt><big>(</big><em>modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.Transform.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform small displacement vectors from new to Cartesian coordinates.</p>
<dl class="docutils">
<dt>Argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">modes</span></tt> &#8211; Small (mass-weighted) displacements (or modes) in
internal coordinates (float numpy array with shape
KxM, where K is the number of internal coordinates
and M is the number of modes)</div>
</div>
</dd>
<dt>Returns:</dt>
<dd>Small non-mass-weighted displacements (or modes) in Cartesian
coordinates (float numpy array with shape 3NxM, where N is the
number of Cartesian coordinates and M is the number of modes)</dd>
</dl>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modes_cartesian</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">modes_internal</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.Transform.get_weighted">
<tt class="descname">get_weighted</tt><big>(</big><big>)</big><a class="headerlink" href="#tamkin.nma.Transform.get_weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True when the transform is already mass-weighted</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.Transform.make_weighted">
<tt class="descname">make_weighted</tt><big>(</big><em>mass_matrix</em><big>)</big><a class="headerlink" href="#tamkin.nma.Transform.make_weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Include mass-weighting into the transformation.</p>
<p>The original transformation is from non-mass-weighted new coordinates
to non-mass-weighted Cartesian coordinates and becomes a transform
from mass-weighted new coordinates to non-mass-weighted Cartesian
coordinates.</p>
<dl class="docutils">
<dt>Argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">mass_matrix</span></tt> &#8211; A MassMatrix instance for the new coordinates</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tamkin.nma.Transform.weighted">
<tt class="descname">weighted</tt><a class="headerlink" href="#tamkin.nma.Transform.weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True when the transform is already mass-weighted</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.MassMatrix">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">MassMatrix</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#tamkin.nma.MassMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A clever mass matrix object. It is sparse when atom coordinates remain
Cartesian in the reduced coordinates.</p>
<dl class="docutils">
<dt>Arguments, if one is given and it is a two-dimensional matrix:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">mass_block</span></tt> &#8211; the mass matrix associated with the transformed
coordinates</div>
</div>
</dd>
<dt>Arguments, if one is given and it is a one-dimensional matrix:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">mass_diag</span></tt> &#8211; the diagonal of the mass matrix associated with
the free atoms (each mass appears three times)</div>
</div>
</dd>
<dt>Arguments, if two are given:  ! Attention for order of arguments.</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">mass_block</span></tt> &#8211; the mass matrix associated with the transformed
coordinates</div>
<div class="line"><tt class="docutils literal"><span class="pre">mass_diag</span></tt> &#8211; the diagonal of the mass matrix associated with
the free atoms (each mass appears three times)</div>
</div>
</dd>
</dl>
<p>The mass of the fixed atoms does not really matter here.</p>
<dl class="method">
<dt id="tamkin.nma.MassMatrix.get_weighted_hessian">
<tt class="descname">get_weighted_hessian</tt><big>(</big><em>hessian</em><big>)</big><a class="headerlink" href="#tamkin.nma.MassMatrix.get_weighted_hessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.Treatment">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">Treatment</tt><a class="headerlink" href="#tamkin.nma.Treatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An abstract base class for the NMA treatments. Derived classes must
override the __call__ function, or they have to override the individual
compute_zeros and compute_hessian methods. Parameters specific for the
treatment are passed to the constructor, see for example the PHVA
implementation.</p>
<dl class="method">
<dt id="tamkin.nma.Treatment.__call__">
<tt class="descname">__call__</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.Treatment.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls compute_hessian and compute_zeros (in order) with same arguments</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">molecule</span></tt> &#8211; a Molecule instance</div>
<div class="line"><tt class="docutils literal"><span class="pre">do_modes</span></tt> &#8211; a boolean indicates whether the modes have to be
computed</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.Treatment.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.Treatment.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>To be computed in derived classes</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">molecule</span></tt> &#8211; a Molecule instance</div>
<div class="line"><tt class="docutils literal"><span class="pre">do_modes</span></tt> &#8211; a boolean indicates whether the modes have to be</div>
</div>
</dd>
</dl>
<p>Attributes to be computed:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">treatment.hessian_small</span></tt>: the Hessian in reduced coordinates</li>
<li><tt class="docutils literal"><span class="pre">treatment.mass_matrix_small</span></tt>: the mass matrix in reduced
coordinates (see MassMatrix class)</li>
<li><tt class="docutils literal"><span class="pre">treatment.transform</span></tt>: (None if <tt class="docutils literal"><span class="pre">do_modes==False</span></tt>) the
transformation from small displacements in reduced coordinates
to small displacements in Cartesian coordinates. (see Transform
class)</li>
</ul>
<p>For the implementation of certain treatments, it is easier to produce
a mass-weighted small Hessian immediately. In such cases, the
transform is readily mass-weighted and mass_matrix_small is None.</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.Treatment.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.Treatment.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>To be computed in derived classes</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">molecule</span></tt> &#8211; a Molecule instance</div>
<div class="line"><tt class="docutils literal"><span class="pre">do_modes</span></tt> &#8211; a boolean indicates whether the modes have to be</div>
</div>
</dd>
</dl>
<p>Attributes to be computed:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">treatment.num_zeros</span></tt>: the number of zero eigenvalues to expect</li>
<li><tt class="docutils literal"><span class="pre">treatment.external_basis</span></tt>: (None if <tt class="docutils literal"><span class="pre">do_modes=False</span></tt>) the
basis of external degrees of freedom. number of basis vectors
matches the number of zeros. These basis vectors are mass-weighted.</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.Full">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">Full</tt><big>(</big><em>im_threshold=1.0</em><big>)</big><a class="headerlink" href="#tamkin.nma.Full" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.Treatment" title="tamkin.nma.Treatment"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.Treatment</span></tt></a></p>
<p>A full vibrational analysis, without transforming to a new set of
coordinates.</p>
<dl class="docutils">
<dt>Optional argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">im_threshold</span></tt> &#8211; Threshold for detection of deviations from
linearity. When a moment of inertia is below
this threshold, it is treated as a zero.</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.Full.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.Full.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_hessian" title="tamkin.nma.Treatment.compute_hessian"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_hessian()</span></tt></a>.</p>
<p>The Hessian is the full 3Nx3N Hessian matrix <tt class="docutils literal"><span class="pre">H</span></tt>.
The mass matrix is the full 3Nx3N mass matrix <tt class="docutils literal"><span class="pre">M</span></tt>.
It is assumed that the coordinates are Cartesian coordinates, so the
mass matrix is diagonal.</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.Full.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.Full.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_zeros" title="tamkin.nma.Treatment.compute_zeros"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_zeros()</span></tt></a>.</p>
<p>The number of zeros should be:</p>
<ul class="simple">
<li>3 for a single atom, nonperiodic calculation</li>
<li>5 for a linear molecule, nonperiodic calculation</li>
<li>6 for a nonlinear molecule, nonperiodic calculation</li>
<li>3 in periodic calculations</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.ConstrainExt">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">ConstrainExt</tt><big>(</big><em>gradient_threshold=0.0001</em>, <em>im_threshold=1.0</em><big>)</big><a class="headerlink" href="#tamkin.nma.ConstrainExt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.Treatment" title="tamkin.nma.Treatment"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.Treatment</span></tt></a></p>
<p>Almost a full vibrational analysis, but with constrained external degrees
of freedom.</p>
<p>Note that the current implementation only works correctly when the
gradient is zero.</p>
<dl class="docutils">
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">gradient_threshold</span></tt> &#8211; The maximum allowed value of the
components of the Cartesian gradient in
atomic units. When the threshold is
exceeded, a ValueError is raised.
[default=1-e4]</div>
<div class="line"><tt class="docutils literal"><span class="pre">im_threshold</span></tt> &#8211; Threshold for detection of deviations from
linearity. When a moment of inertia is below
this threshold, it is treated as a zero.</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.ConstrainExt.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.ConstrainExt.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_hessian" title="tamkin.nma.Treatment.compute_hessian"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_hessian()</span></tt></a></p>
<p>First a basis is constructed for the internal coordinates. The 3N-6
(or 3N-5) basis vectors of length 3N (matrix B is (3N-6)x3N) are
mass-weighted.
The ConstrainExt Hessian is then: <tt class="docutils literal"><span class="pre">B^T</span> <span class="pre">H</span> <span class="pre">B</span></tt>.
This matrix is already mass weigthed, such that no ConstrainExt mass
matrix needs to be specified.</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.ConstrainExt.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.ConstrainExt.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_zeros" title="tamkin.nma.Treatment.compute_zeros"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_zeros()</span></tt></a>.</p>
<p>The number of zeros is set to 0, because the global translations
and rotations are already projected out.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.PHVA">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">PHVA</tt><big>(</big><em>fixed</em>, <em>svd_threshold=1e-05</em><big>)</big><a class="headerlink" href="#tamkin.nma.PHVA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.Treatment" title="tamkin.nma.Treatment"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.Treatment</span></tt></a></p>
<p>Perform the partial Hessian vibrational analysis.</p>
<p>Part of the system is fixed during the vibrational analysis: the fixed
atoms are kept at their reference positions. The rest of the atoms can
still vibrate.</p>
<p>See references:</p>
<ul class="simple">
<li>J.D. Head, Int. J. Quantum Chem. 65, 827 (1997)</li>
<li>J.D. Head and Y. Shi, Int. J. Quantum Chem. 75, 81 (1999)</li>
<li>J.D. Head, Int. J. Quantum Chem. 77, 350 (2000)</li>
<li><ol class="first upperalpha" start="8">
<li>Li and J. Jensen, Theor. Chem. Acc. 107, 211 (2002)</li>
</ol>
</li>
</ul>
<dl class="docutils">
<dt>Argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">fixed</span></tt> &#8211; a list with fixed atoms, counting starts from zero.</div>
</div>
</dd>
<dt>Optional argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">svd_threshold</span></tt> &#8211; threshold for detection of deviations for
linearity</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.PHVA.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.PHVA.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_hessian" title="tamkin.nma.Treatment.compute_hessian"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_hessian()</span></tt></a>.</p>
<p>The Hessian matrix for the PHVA is the submatrix of the full (3Nx3N)
Hessian, corresponding with the non-fixed atoms: <tt class="docutils literal"><span class="pre">H_nonfixed</span></tt>.
The mass matrix for the PHVA is the (diagonal) submatrix of the
full (3Nx3N) mass matrix, corresponding with the non-fixed atoms:
<tt class="docutils literal"><span class="pre">M_nonfixed</span></tt>.
So it is a diagonal matrix with the masses of the non-fixed atoms on
the diagonal.</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.PHVA.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.PHVA.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_zeros" title="tamkin.nma.Treatment.compute_zeros"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_zeros()</span></tt></a>.</p>
<p>This is a bit tricky. Most of the times the number of zero eigenvalues
is zero, but there are a few exceptions. When there is one fixed
point, there are in general three zeros. When there are two (or more
colinear fixed atoms), there is in general one zero. When both the
fixed and the free atoms are colinear, there are no zeros.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.VSA">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">VSA</tt><big>(</big><em>subs</em>, <em>svd_threshold=1e-05</em><big>)</big><a class="headerlink" href="#tamkin.nma.VSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.Treatment" title="tamkin.nma.Treatment"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.Treatment</span></tt></a></p>
<p>Perform a Vibrational Subsystem Analysis.</p>
<p>Frequencies and modes are computed with the VSA approach, as described in
the references:</p>
<ul class="simple">
<li><ol class="first upperalpha" start="23">
<li>Zheng, B.R. Brooks, J. Biophys. 89, 167 (2006)</li>
</ol>
</li>
<li>H.L. Woodcock, W. Zheng, A. Ghysels, Y. Shao, J. Kong, B.R. Brooks,
J. Chem. Phys. 129 (21), Art. No. 214109 (2008)</li>
</ul>
<p>The system is partitioned into a subsystem and an environment. The subsystem
atoms are allowed to vibrate, while the environment atoms follow the motions
of the subsystem atoms. The environment atoms are force free.</p>
<dl class="docutils">
<dt>One argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">subs</span></tt> &#8211; a list with the subsystem atoms, counting starts from
zero.</div>
</div>
</dd>
<dt>Optional argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">svd_threshold</span></tt> &#8211; threshold for detection of deviations for
linearity</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.VSA.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.VSA.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_hessian" title="tamkin.nma.Treatment.compute_hessian"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_hessian()</span></tt></a>.</p>
<p>The VSA Hessian reads: <tt class="docutils literal"><span class="pre">H_ss</span> <span class="pre">-</span> <span class="pre">H_se</span> <span class="pre">(H_ee)**(-1)</span> <span class="pre">H_es</span></tt>,
the VSA mass matrix reads: <tt class="docutils literal"><span class="pre">M_s</span> <span class="pre">-</span> <span class="pre">H_se</span> <span class="pre">(H_ee)**(-1)</span> <span class="pre">M_e</span> <span class="pre">(H_ee)**(-1)</span> <span class="pre">H_es</span></tt>,
where the indices <tt class="docutils literal"><span class="pre">s</span></tt> and <tt class="docutils literal"><span class="pre">e</span></tt> refer to the subsystem and environment
atoms respectively.</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.VSA.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.VSA.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_zeros" title="tamkin.nma.Treatment.compute_zeros"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_zeros()</span></tt></a>.</p>
<p>The number of zeros should be:</p>
<ul class="simple">
<li>3 for subsystem = a single atom, nonperiodic calculation</li>
<li>5 for subsystem = a linear molecule, nonperiodic calculation</li>
<li>6 for subsystem = a nonlinear molecule, nonperiodic calculation</li>
<li>3 in periodic calculations</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.VSANoMass">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">VSANoMass</tt><big>(</big><em>subs</em>, <em>svd_threshold=1e-05</em><big>)</big><a class="headerlink" href="#tamkin.nma.VSANoMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.Treatment" title="tamkin.nma.Treatment"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.Treatment</span></tt></a></p>
<p>Perform a Vibrational Subsystem Analysis, without taking into account the
mass of the environment.</p>
<p>Frequencies and modes are computed as described in the reference:</p>
<ul class="simple">
<li><ol class="first upperalpha" start="23">
<li>Zheng, B.R. Brooks, Journal of Biophysics 89, 167 (2006)</li>
</ol>
</li>
<li>A. Ghysels, V. Van Speybroeck, E. Pauwels, S. Catak, B.R. Brooks,
D. Van Neck, M. Waroquier, Journal of Computational Chemistry 31 (5),
94-1007 (2010)</li>
</ul>
<p>The system is partitioned into a subsystem and an environment. The subsystem
atoms are allowed to vibrate, while the environment atoms follow the motions
of the subsystem atoms. The environment atoms are force free.
Moreover, the VSA is performed according to the original version of 2006:
no mass correction for the environment is included.
This version of VSA corresponds to the approximation
of zero mass for all environment atoms.</p>
<dl class="docutils">
<dt>One argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">subs</span></tt> &#8211; a list with the subsystem atoms, counting starts from
zero.</div>
</div>
</dd>
<dt>Optional argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">svd_threshold</span></tt> &#8211; threshold for detection of deviations for
linearity</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.VSANoMass.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.VSANoMass.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_hessian" title="tamkin.nma.Treatment.compute_hessian"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_hessian()</span></tt></a>.</p>
<p>The VSANoMass Hessian reads: <tt class="docutils literal"><span class="pre">H_ss</span> <span class="pre">-</span> <span class="pre">H_se</span> <span class="pre">(H_ee)**(-1)</span> <span class="pre">H_es</span></tt>.
and the VSANoMass mass matrix reads: <tt class="docutils literal"><span class="pre">M_s</span></tt>,
where the indices <tt class="docutils literal"><span class="pre">s</span></tt> and <tt class="docutils literal"><span class="pre">e</span></tt> refer to the subsystem and environment
atoms respectively.</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.VSANoMass.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.VSANoMass.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_zeros" title="tamkin.nma.Treatment.compute_zeros"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_zeros()</span></tt></a>.</p>
<p>The number of zeros should be:</p>
<ul class="simple">
<li>3 for subsystem = a single atom, nonperiodic calculation</li>
<li>5 for subsystem = a linear molecule, nonperiodic calculation</li>
<li>6 for subsystem = a nonlinear molecule, nonperiodic calculation</li>
<li>3 in periodic calculations</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.MBH">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">MBH</tt><big>(</big><em>blocks</em>, <em>do_gradient_correction=True</em>, <em>svd_threshold=1e-05</em><big>)</big><a class="headerlink" href="#tamkin.nma.MBH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.Treatment" title="tamkin.nma.Treatment"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.Treatment</span></tt></a></p>
<p>The Mobile Block Hessian approach.</p>
<p>Frequencies and modes are computed with the MBH approach, as described in
the refences:</p>
<ul class="simple">
<li>&#8220;Vibrational modes in partially optimized molecular systems&#8221;, An Ghysels,
Dimitri Van Neck, Veronique Van Speybroeck, Toon Verstraelen and Michel
Waroquier, Journal of Chemical Physics, Vol. 126 (22), Art. No. 224102,
2007, <a class="reference external" href="http://dx.doi.org/1.2737444">http://dx.doi.org/1.2737444</a></li>
<li>&#8220;Cartesian formulation of the Mobile Block Hesian Approach to vibrational
analysis in partially optimized systems&#8221;, An Ghysels, Dimitri Van Neck and
Michel Waroquier, Journal of Chemical Physics, Vol. 127 (16), Art. No.
164108, 2007, <a class="reference external" href="http://dx.doi.org/1.2789429">http://dx.doi.org/1.2789429</a></li>
<li>&#8220;Calculating reaction rates with partial Hessians: validation of the MBH
approach&#8221;, An Ghysels, Veronique Van Speybroeck, Toon Verstraelen, Dimitri
Van Neck and Michel Waroquier, Journal of Chemical Theory and Computation,
Vol. 4 (4), 614-625, 2008, <a class="reference external" href="http://dx.doi.org/ct7002836">http://dx.doi.org/ct7002836</a></li>
</ul>
<p>For the Mobile Block Hessian method with linked blocks, please refer to the
following papers:</p>
<ul class="simple">
<li>&#8220;Mobile Block Hessian approach with linked blocks: an efficient approach
for the calculation of frequencies in macromolecules&#8221;, An Ghysels,
Veronique Van Speybroeck, Ewald Pauwels, Dimitri Van Neck, Bernard R.
Brooks and Michel Waroquier, Journal of Chemical Theory and Computation,
Vol. 5 (5), 1203-1215, 2009, <a class="reference external" href="http://dx.doi.org/ct800489r">http://dx.doi.org/ct800489r</a></li>
<li>&#8220;Normal modes for large molecules with arbitrary link constraints in the
mobile block Hessian approach&#8221;, An Ghysels, Dimitri Van Neck, Bernard R.
Brooks, Veronique Van Speybroeck and Michel Waroquier, Journal of Chemical
Physics, Vol. 130 (18), Art. No. 084107, 2009, <a class="reference external" href="http://dx.doi.org/1.3071261">http://dx.doi.org/1.3071261</a></li>
</ul>
<p>The system is partitioned into blocks which are only allowed to move as
rigid bodies during the vibrational analysis. Atoms that are not part of a
block can still move individually. The internal geometry of the blocks need
not be optimized, because the MBH method performs a gradient correction to
account for the internal forces. Only the position and orientation of each
block should be optimized. This make MBH an appropriate method to perform
NMA in partially optimized structures.</p>
<dl class="docutils">
<dt>One argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">blocks</span></tt> &#8211; a list of blocks, each block is a list of atoms,
counting starts from zero.</div>
</div>
</dd>
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">do_gradient_correction</span></tt> &#8211; boolean, whether gradient correction
to MBH should be added</div>
<div class="line"><tt class="docutils literal"><span class="pre">svd_threshold</span></tt> &#8211; threshold for zero singular values in svd</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.MBH.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.MBH.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_hessian" title="tamkin.nma.Treatment.compute_hessian"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_hessian()</span></tt></a>.</p>
<p>Gather all information about the block choice in the
blkinfo attribute. If adjoined blocks (blocks with common atoms)
are present, an extra STRICT block choice is defined: the partitioning
where each atom belongs to only one block.</p>
<p>First, the 3Nxd matrix U is constructed from the column vectors describing
the block motions. At this point, the strict partitioning is used.
The Hessian is equal to: <tt class="docutils literal"><span class="pre">Hp</span> <span class="pre">=</span> <span class="pre">U^T</span> <span class="pre">H</span> <span class="pre">U`</span> <span class="pre">+</span> <span class="pre">G:C`.</span> <span class="pre">The</span> <span class="pre">term</span> <span class="pre">``G:C</span></tt> is the
gradient correction. The mass matrix is equal to: <tt class="docutils literal"><span class="pre">Mp</span> <span class="pre">=</span> <span class="pre">U^T</span> <span class="pre">M</span> <span class="pre">U</span></tt>.</p>
<p>Second, impose the link constraints between blocks, if any of the blocks
are adjoined. The matrix K constains the linking constraints. If
nullspace is the null space of K, then the final Mobile block Hessian
reads: <tt class="docutils literal"><span class="pre">Hy</span> <span class="pre">=</span> <span class="pre">nullspace^T</span> <span class="pre">Hp</span> <span class="pre">nullspace</span> <span class="pre">+</span> <span class="pre">Gp:Cp</span></tt>. The term <tt class="docutils literal"><span class="pre">Gp:Cp</span></tt>
is the gradient correction. The Mobile Block mass matrix is equal to:
<tt class="docutils literal"><span class="pre">My</span> <span class="pre">=</span> <span class="pre">nullspace^T</span> <span class="pre">Mp</span> <span class="pre">nullspace</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.MBH.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.MBH.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_zeros" title="tamkin.nma.Treatment.compute_zeros"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_zeros()</span></tt></a>.</p>
<p>The number of zeros should be:</p>
<ul class="simple">
<li>3 for a single atom, nonperiodic calculation</li>
<li>5 for a linear molecule, nonperiodic calculation</li>
<li>6 for a nonlinear molecule, nonperiodic calculation</li>
<li>3 in periodic calculations</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.Blocks">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">Blocks</tt><big>(</big><em>blocks</em>, <em>molecule</em>, <em>svd_threshold</em><big>)</big><a class="headerlink" href="#tamkin.nma.Blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Object that extracts all information from a block choice.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">blocks</span></tt> &#8211; a list of lists of atoms
[ [at1,at5,at3], [at4,at5], ...]
with a list of atoms for each block</div>
<div class="line"><tt class="docutils literal"><span class="pre">molecule</span></tt> &#8211; Molecule object, necessary for N (total nb of atoms)
and positions (linearity of blocks).</div>
<div class="line"><tt class="docutils literal"><span class="pre">svd_trheshold</span></tt> &#8211; threshold for zero singular values in svd</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="tamkin.nma.PHVA_MBH">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">PHVA_MBH</tt><big>(</big><em>fixed</em>, <em>blocks</em>, <em>do_gradient_correction=True</em>, <em>svd_threshold=1e-05</em><big>)</big><a class="headerlink" href="#tamkin.nma.PHVA_MBH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.MBH" title="tamkin.nma.MBH"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.MBH</span></tt></a></p>
<p>The Mobile Block Hessian combined with the Partial Hessian Vibrational Analysis.</p>
<p>The system is partitioned into</p>
<ul class="simple">
<li>blocks which are only allowed to move as rigid bodies (the MBH concept,
see <a class="reference internal" href="#tamkin.nma.PHVA" title="tamkin.nma.PHVA"><tt class="xref py py-class docutils literal"><span class="pre">PHVA</span></tt></a>),</li>
<li>fixed atoms which are not allowed to move at all (the PHVA concept, see
<a class="reference internal" href="#tamkin.nma.MBH" title="tamkin.nma.MBH"><tt class="xref py py-class docutils literal"><span class="pre">MBH</span></tt></a>).</li>
<li>single atoms which are allowed to vibrate individually</li>
</ul>
<p>The internal geometry of the blocks does not have to be optimized. The
positions of the fixed atoms also do not have to be optimized.
This make the PHVA_MBH an appropriate method to perform NMA in partially
optimized structures.</p>
<dl class="docutils">
<dt>Two arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">fixed</span></tt> &#8211; a list with fixed atoms, counting starts from zero.</div>
<div class="line"><tt class="docutils literal"><span class="pre">blocks</span></tt> &#8211; a list of blocks, each block is a list of atoms</div>
</div>
</dd>
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">svd_threshold</span></tt> &#8211; threshold for zero singular values in svd</div>
<div class="line"><tt class="docutils literal"><span class="pre">do_gradient_correction</span></tt> &#8211; boolean, whether gradient correction
to MBH part should be added
[default=True]</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.PHVA_MBH.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.PHVA_MBH.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_hessian" title="tamkin.nma.Treatment.compute_hessian"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_hessian()</span></tt></a>.</p>
<p>First, the non-fixed atoms are cut out of the molecular system, i.e.
the single atoms and the atoms belonging to the blocks and stored in a
<em>submolecule</em>.
Next, the regular MBH concept is applied on this submolecule.</p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.PHVA_MBH.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.PHVA_MBH.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_zeros" title="tamkin.nma.Treatment.compute_zeros"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_zeros()</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.Constrain">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">Constrain</tt><big>(</big><em>constraints</em>, <em>do_gradient_correction=True</em>, <em>svd_threshold=1e-05</em><big>)</big><a class="headerlink" href="#tamkin.nma.Constrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.Treatment" title="tamkin.nma.Treatment"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.Treatment</span></tt></a></p>
<p>Perform a normal mode analysis where part of the internal coordinates are
constrained to a fixed value.</p>
<p>The gradient corrections are taken into account correctly. At present, only
distance constraints are implemented. In principle, the routine can be
adapted to angle and dihedral angle constraints.</p>
<dl class="docutils">
<dt>One argument:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">constraints</span></tt> &#8211; a list with constraints of internal coordinates:
[at1,at2] to constrain a distance,
[at1,at2,at3] to constrain an angle,
[at1,at2,at3,at4] to constrain a dihedral angle.</div>
</div>
</dd>
<dt>Optional:</dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">do_gradient_correction</span></tt> &#8211; whether gradient correction should
be applied</div>
<div class="line"><tt class="docutils literal"><span class="pre">svd_threshold</span></tt> &#8211; threshold for singular value decomposition</div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="tamkin.nma.Constrain.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.Constrain.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_hessian" title="tamkin.nma.Treatment.compute_hessian"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_hessian()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="tamkin.nma.Constrain.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.Constrain.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#tamkin.nma.Treatment.compute_zeros" title="tamkin.nma.Treatment.compute_zeros"><tt class="xref py py-meth docutils literal"><span class="pre">Treatment.compute_zeros()</span></tt></a>.</p>
<p>The number of zeros should be:</p>
<ul class="simple">
<li>3 for a single atom, nonperiodic calculation</li>
<li>5 for a linear molecule, nonperiodic calculation</li>
<li>6 for a nonlinear molecule, nonperiodic calculation</li>
<li>3 in periodic calculations</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tamkin.nma.MBHConstrainExt">
<em class="property">class </em><tt class="descclassname">tamkin.nma.</tt><tt class="descname">MBHConstrainExt</tt><big>(</big><em>blocks</em>, <em>do_gradient_correction=True</em>, <em>svd_threshold=1e-05</em><big>)</big><a class="headerlink" href="#tamkin.nma.MBHConstrainExt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tamkin.nma.MBH" title="tamkin.nma.MBH"><tt class="xref py py-class docutils literal"><span class="pre">tamkin.nma.MBH</span></tt></a></p>
<p>The Mobile Block Hessian approach with the Eckart constraints imposed</p>
<p>This method is completely similar to the MBH, except that first the
global translations and rotations are first projected out of the
Hessian before applying the block partitioning and projecting by
the MBH. The contribution of the gradient is also adapted.
In case of a periodic simulation, only the global translations
are projected out.</p>
<dl class="method">
<dt id="tamkin.nma.MBHConstrainExt.compute_hessian">
<tt class="descname">compute_hessian</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.MBHConstrainExt.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tamkin.nma.MBHConstrainExt.compute_zeros">
<tt class="descname">compute_zeros</tt><big>(</big><em>molecule</em>, <em>do_modes</em><big>)</big><a class="headerlink" href="#tamkin.nma.MBHConstrainExt.compute_zeros" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="tools-to-analyze-frequencies-and-modes">
<h2>3.2. Tools to analyze frequencies and modes<a class="headerlink" href="#tools-to-analyze-frequencies-and-modes" title="Permalink to this headline">¶</a></h2>
<p>Some additional tools are in the <tt class="docutils literal"><span class="pre">nmatools.py</span></tt> code.</p>
<span class="target" id="module-tamkin.nmatools"></span><dl class="function">
<dt id="tamkin.nmatools.compute_overlap">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">compute_overlap</tt><big>(</big><em>nma1</em>, <em>nma2</em>, <em>filename=None</em>, <em>unit='au'</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.compute_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute overlap of modes and print to file if requested</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line">nma1  &#8211;  modes and frequencies (see below)</div>
<div class="line">nma2  &#8211;  modes and frequencies (see below)</div>
</div>
</dd>
<dt>Optional argument:</dt>
<dd><div class="first last line-block">
<div class="line">filename  &#8211;  when given, the overlap is written to file by the
function write_overlap</div>
<div class="line">unit  &#8211;  unit in which frequencies should be printed in the
file: au [default] or 1/centimeter [cm1]</div>
</div>
</dd>
</dl>
<p>The nma arguments can have different formats:</p>
<ol class="arabic simple">
<li>an NMA object</li>
<li>a tuple or list with two elements: modes and frequencies</li>
<li>a numpy array with the mass-weighted modes</li>
<li>a numpy array with one mass-weighted mode</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="tamkin.nmatools.write_overlap">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">write_overlap</tt><big>(</big><em>freqs1</em>, <em>freqs2</em>, <em>overlap</em>, <em>filename='overlap.csv'</em>, <em>unit='au'</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.write_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the overlap matrix to a csv file</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line">freqs1  &#8211;  the list of frequencies associated with the rows of the
overlap matrix</div>
<div class="line">freqs2  &#8211;  the list of frequencies associated with the columns of the
overlap matrix</div>
<div class="line">overlap  &#8211;  the overlap matrix</div>
</div>
</dd>
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line">filename  &#8211;  the file to write to [default=&#8221;overlap.csv&#8221;]</div>
<div class="line">unit      &#8211;  unit in which frequencies are printed in file:
1/centimeter (cm1) or au  [default]</div>
</div>
</dd>
</dl>
<p>The table contains the following blocks:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&nbsp;</td>
<td>freqs2</td>
</tr>
<tr class="row-even"><td>freqs1^T</td>
<td>mat1^T . mat2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tamkin.nmatools.compute_delta">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">compute_delta</tt><big>(</big><em>coor1</em>, <em>coor2</em>, <em>masses=None</em>, <em>normalize=False</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.compute_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mass weighted delta vector between two conformations</p>
<p>It is assumed that the structures have been aligned (center of mass,
orientation) previously.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line">coor1  &#8211;  coordinates of structure 1 in a numpy array with shape (N,3)</div>
<div class="line">coor2  &#8211;  coordinates of structure 2 in a numpy array with shape (N,3)</div>
</div>
</dd>
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line">masses
&#8211;  when given, the mass-weighted delta vector is computed</div>
<div class="line">normalize
&#8211;  whether delta vector should be normalized [default=False]</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tamkin.nmatools.compute_sensitivity_freq">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">compute_sensitivity_freq</tt><big>(</big><em>nma</em>, <em>index</em>, <em>symmetric=False</em>, <em>massweight=True</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.compute_sensitivity_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sensity of the index-th frequency to changes in the mass-weighted Hessian elements.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd>nma  &#8211;  an NMA object</dd>
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line">symmetric  &#8211;  when True, a slightly different formula is used to take
into account the symmetry of the Hessian [default=False]</div>
<div class="line">massweight  &#8211;  when True, a mass-weighted hessian is considered</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tamkin.nmatools.create_blocks_peptide_charmm">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">create_blocks_peptide_charmm</tt><big>(</big><em>filename</em>, <em>label='normal'</em>, <em>blocksize=1</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.create_blocks_peptide_charmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Create blocks list for CHARMM peptides</p>
<dl class="docutils">
<dt>Argument:</dt>
<dd><div class="first last line-block">
<div class="line">filename  &#8211;  the CHARMM coordinate file (typically extension .crd or
.cor)</div>
</div>
</dd>
<dt>Optional argument:</dt>
<dd><div class="first last line-block">
<div class="line">label  &#8211;  type of MBH blocks: RTB, dihedral, RHbending, normal
[default=normal]</div>
<div class="line">blocksize  &#8211;  when using the RTB scheme, blocksize defines the number
of residues in a block</div>
</div>
</dd>
</dl>
<p>TODO: referenties</p>
</dd></dl>

<dl class="function">
<dt id="tamkin.nmatools.create_subs_peptide_charmm">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">create_subs_peptide_charmm</tt><big>(</big><em>filename, atomtypes=['CA'], frequency=1</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.create_subs_peptide_charmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Create subsystem selection for CHARMM peptides</p>
<dl class="docutils">
<dt>Argument:</dt>
<dd><div class="first last line-block">
<div class="line">filename  &#8211;  the CHARMM coordinate file (typically extension .crd or
.cor)</div>
</div>
</dd>
<dt>Optional argument:</dt>
<dd><div class="first last line-block">
<div class="line">atomtypes  &#8211;  list of strings. Let only these atom types be part of
the subsystem.</div>
<div class="line">frequency  &#8211;  let only one out of every <em>frequency</em> residues be part
of the subsystem.</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tamkin.nmatools.plot_spectrum_lines">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">plot_spectrum_lines</tt><big>(</big><em>filename</em>, <em>all_freqs</em>, <em>low=None</em>, <em>high=None</em>, <em>title=None</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.plot_spectrum_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot multiple spectra in a comparative line plot</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line">filename  &#8211;  the filename to write the figure to (the extension and
the matplotlib settings determine the file format)</div>
<div class="line">all_freqs  &#8211;  a list with spectra, each item in the list is an array
with multiple frequencies that represent one spectrum</div>
</div>
</dd>
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line">low  &#8211;  minimum on x-axis, in atomic units</div>
<div class="line">high  &#8211;  maximum on x-axis, in atomic units</div>
<div class="line">title  &#8211;  title for plot (a string)</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tamkin.nmatools.plot_spectrum_dos">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">plot_spectrum_dos</tt><big>(</big><em>filename</em>, <em>all_freqs</em>, <em>low=None</em>, <em>high=None</em>, <em>imax=None</em>, <em>step=7.251632778591094e-07</em>, <em>width=7.251632778591094e-06</em>, <em>all_amps=None</em>, <em>title=None</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.plot_spectrum_dos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot multiple spectra in a comparative density of states plot</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><div class="first last line-block">
<div class="line">filename  &#8211;  the filename to write the figure too (the extension and
the matplotlib settings determine the file format)</div>
<div class="line">all_freqs  &#8211;  a list with spectra, each item in the list is an array
with multiple frequencies that represent one spectrum</div>
</div>
</dd>
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line">low  &#8211;  minimum on x-axis, in atomic units</div>
<div class="line">high  &#8211;  maximum on x-axis, in atomic units</div>
<div class="line">imax  &#8211;  maximum intensity on y-axis, no unit</div>
<div class="line">step  &#8211;  resulotion of plot, in atomic units</div>
<div class="line">width  &#8211;  width of Gaussian, in atomic units</div>
<div class="line">all_amps  &#8211;  list of arrays in the same format as all_freqs with an
amplitude for each individual frequency</div>
<div class="line">title  &#8211;  title for plot (a string)</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tamkin.nmatools.create_enm_molecule">
<tt class="descclassname">tamkin.nmatools.</tt><tt class="descname">create_enm_molecule</tt><big>(</big><em>molecule</em>, <em>selected=None</em>, <em>numbers=None</em>, <em>masses=None</em>, <em>rcut=15.117809071370017</em>, <em>K=1.0</em>, <em>periodic=None</em><big>)</big><a class="headerlink" href="#tamkin.nmatools.create_enm_molecule" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a molecule according to the Elastic Network Model</p>
<dl class="docutils">
<dt>Argument:</dt>
<dd><div class="first last line-block">
<div class="line">molecule  &#8211;  The molecule to start from. can be two types: (i) a
Molecule object or (ii) a numpy array with shape (N,3)
with coordinates in atomic units.</div>
</div>
</dd>
</dl>
<p>When a Molecule object is given, atom numbers, masses and periodic are
inherited from the molecule, unless they are specified explicitly in the
optional arguments.</p>
<dl class="docutils">
<dt>Optional arguments:</dt>
<dd><div class="first last line-block">
<div class="line">selected  &#8211;  Selection of atoms to include in the ENM model. This can
be a list or array of atom indices (length &lt;= N), or an
array of booleans (length = N).</div>
<div class="line">numbers  &#8211;  atom numbers in the ENM model (length = N). default is
array of ones or the numbers from the molecule object.</div>
<div class="line">masses  &#8211;  atomic masses in atomic units in the ENM model (length = N).
default is array of hydrogen masses or the masses from the
molecule object.</div>
<div class="line">rcut  &#8211;  cutoff distance between interacting pairs in atomic units</div>
<div class="line">K  &#8211;  strength of the interaction in atomic units (Hartree/Bohr**2).
The interaction strength is the same for all interacting pairs.</div>
</div>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Normal mode analysis</a><ul>
<li><a class="reference internal" href="#the-different-nma-models">3.1. The different NMA models</a></li>
<li><a class="reference internal" href="#tools-to-analyze-frequencies-and-modes">3.2. Tools to analyze frequencies and modes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="io.html"
                        title="previous chapter">2. Input/output</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pf.html"
                        title="next chapter">4. Partition functions</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/reference/nma.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pf.html" title="4. Partition functions"
             >next</a> |</li>
        <li class="right" >
          <a href="io.html" title="2. Input/output"
             >previous</a> |</li>
        <li><a href="../index.html">TAMkin 1.0.5 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Toon Verstraelen, An Ghysels.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>